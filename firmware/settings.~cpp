#include <Arduino.h>
#include <EEPROM.h>

static constexpr int EEPROM_SIZE = SPI_FLASH_SEC_SIZE; // 4096 for now
static bool settings_dirty = false;

//! Find a record containing specified tag
static bool settings_locate(uint32_t tag_to_find,
	uint32_t *_index, uint32_t *_length, uint32_t *_aligned_length)
{
	uint8_t *ptr = EEPROM.getDataPtr(); // first 4bytes are checksum

	// walk through eeprom to find specified tag
	// data format for a record is:
	// + 0: tag    (4bytes)
	// + 4: length (4bytes)
	// + 8: data   ('length' bytes aligned up to 4bytes)

	for(uint32_t i = 4; i < EEPROM_SIZE;)
	{
		uint32_t index = i;

		if(i + 4 > EEPROM_SIZE) return false; // corrupted
		uint32_t tag = *reinterpret_cast<uint32_t*>(ptr + i);
		if(tag == 0xffffffff) return false; // end of data
		i += 4;
		
		if(i + 4 > EEPROM_SIZE) return false; // corrupted
		uint32_t length = *reinterpret_cast<uint32_t*>(ptr + i);
		i += 4;

		uint32_t aligned_length = (length + 3) & (~3);
		if(i + aligned_length > EEPROM_SIZE) return false; // corrupted
		i += aligned_length;

		if(tag_to_find == tag)
		{
			if(_index) *_index = index;
			if(_length) *_length = length;
			if(_aligned_length) *_aligned_length = aligned_length;
			return true;
		}
	}

	return false;
}

//! begin settings subsystem
void settings_begin()
{
	EEPROM.begin(EEPROM_SIZE);

	// check EEPROM data is not corrupted
}

//! erase a record
bool settings_erase(uint32_t tag_to_erase)
{
	uint32_t index = 0;
	uint32_t aligned_length = 0;
	if(settings_locate(tag_to_erase, &index, nullptr, &aligned_length))
	{
		// located; erase the content
		uint8_t *ptr = EEPROM.getDataPtr();
		memmove(ptr + index, ptr + index + aligned_length,
			EEPROM_SIZE - (index + aligned_length) );

		// put sentinel at the free space
		memset(ptr + EEPROM_SIZE - aligned_length, 0xff, aligned_length);

		return true;
	}
	return false;
}
